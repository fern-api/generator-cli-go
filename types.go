// This file was auto-generated by Fern from our API Definition.

package generatorcli

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/fern-api/generator-cli-go/core"
)

// The configuration used to specify a generator's set of supported features.
// This is static data associated with a particular version of a generator, and
// is expected to be written as a static features.yml file in the generator's
// repository.
type FeatureConfig struct {
	Features []*FeatureSpec `json:"features,omitempty" url:"features,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FeatureConfig) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeatureConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler FeatureConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeatureConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeatureConfig) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// A unique identifier for a feature (e.g. OPTIONALS). This is typed as a freeform string
// to allow for arbitrary features, but callers are expected to use the StructuredFeatureId
// string representation whenever possible.
type FeatureId struct {
	String              string
	StructuredFeatureId StructuredFeatureId
}

func (f *FeatureId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.String = valueString
		return nil
	}
	var valueStructuredFeatureId StructuredFeatureId
	if err := json.Unmarshal(data, &valueStructuredFeatureId); err == nil {
		f.StructuredFeatureId = valueStructuredFeatureId
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FeatureId) MarshalJSON() ([]byte, error) {
	if f.String != "" {
		return json.Marshal(f.String)
	}
	if f.StructuredFeatureId != "" {
		return json.Marshal(f.StructuredFeatureId)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FeatureIdVisitor interface {
	VisitString(string) error
	VisitStructuredFeatureId(StructuredFeatureId) error
}

func (f *FeatureId) Accept(visitor FeatureIdVisitor) error {
	if f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.StructuredFeatureId != "" {
		return visitor.VisitStructuredFeatureId(f.StructuredFeatureId)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// A specification for a feature supported by a generator. This includes the
// feature's ID, a description, and any additional information that should be
// included in the README.md.
type FeatureSpec struct {
	Id          *FeatureId `json:"id,omitempty" url:"id,omitempty"`
	Description *string    `json:"description,omitempty" url:"description,omitempty"`
	Addendum    *string    `json:"addendum,omitempty" url:"addendum,omitempty"`
	Advanced    *bool      `json:"advanced,omitempty" url:"advanced,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FeatureSpec) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeatureSpec) UnmarshalJSON(data []byte) error {
	type unmarshaler FeatureSpec
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeatureSpec(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeatureSpec) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Unique identifiers for features that can be demonstrated with snippets.
type StructuredFeatureId string

const (
	StructuredFeatureIdAuthentication StructuredFeatureId = "AUTHENTICATION"
	StructuredFeatureIdErrors         StructuredFeatureId = "ERRORS"
	StructuredFeatureIdUsage          StructuredFeatureId = "USAGE"
	StructuredFeatureIdPagination     StructuredFeatureId = "PAGINATION"
	StructuredFeatureIdRetries        StructuredFeatureId = "RETRIES"
	StructuredFeatureIdRequestOptions StructuredFeatureId = "REQUEST_OPTIONS"
	StructuredFeatureIdStreaming      StructuredFeatureId = "STREAMING"
	StructuredFeatureIdTimeouts       StructuredFeatureId = "TIMEOUTS"
	StructuredFeatureIdCustomClient   StructuredFeatureId = "CUSTOM_CLIENT"
	StructuredFeatureIdContributing   StructuredFeatureId = "CONTRIBUTING"
)

func NewStructuredFeatureIdFromString(s string) (StructuredFeatureId, error) {
	switch s {
	case "AUTHENTICATION":
		return StructuredFeatureIdAuthentication, nil
	case "ERRORS":
		return StructuredFeatureIdErrors, nil
	case "USAGE":
		return StructuredFeatureIdUsage, nil
	case "PAGINATION":
		return StructuredFeatureIdPagination, nil
	case "RETRIES":
		return StructuredFeatureIdRetries, nil
	case "REQUEST_OPTIONS":
		return StructuredFeatureIdRequestOptions, nil
	case "STREAMING":
		return StructuredFeatureIdStreaming, nil
	case "TIMEOUTS":
		return StructuredFeatureIdTimeouts, nil
	case "CUSTOM_CLIENT":
		return StructuredFeatureIdCustomClient, nil
	case "CONTRIBUTING":
		return StructuredFeatureIdContributing, nil
	}
	var t StructuredFeatureId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StructuredFeatureId) Ptr() *StructuredFeatureId {
	return &s
}

// The configuration used to interact with a GitHub repository.
type GitHubConfig struct {
	// The directory from which to read the contents of the GitHub repository.
	SourceDirectory string `json:"sourceDirectory" url:"sourceDirectory"`
	// The URI of the GitHub repository.
	Uri string `json:"uri" url:"uri"`
	// The token used to access the GitHub repository.
	Token string `json:"token" url:"token"`
	// The branch to use when interacting with the GitHub repository.
	Branch *string `json:"branch,omitempty" url:"branch,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GitHubConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GitHubConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GitHubConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GitHubConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GitHubConfig) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type CargoPublishInfo struct {
	PackageName string `json:"packageName" url:"packageName"`
	Version     string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CargoPublishInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CargoPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CargoPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CargoPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CargoPublishInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ComposerPublishInfo struct {
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ComposerPublishInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ComposerPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ComposerPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ComposerPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ComposerPublishInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CsharpInfo struct {
	PublishInfo *NugetPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CsharpInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CsharpInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CsharpInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CsharpInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CsharpInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomSection struct {
	Name     string   `json:"name" url:"name"`
	Language Language `json:"language" url:"language"`
	Content  string   `json:"content" url:"content"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomSection) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomSection) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomSection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomSection(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomSection) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type GithubRemote struct {
	// A full repo url (i.e. https://github.com/fern-api/fern)
	RepoUrl string `json:"repoUrl" url:"repoUrl"`
	// The token used to clone the GitHub repository.
	InstallationToken string `json:"installationToken" url:"installationToken"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GithubRemote) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GithubRemote) UnmarshalJSON(data []byte) error {
	type unmarshaler GithubRemote
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GithubRemote(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GithubRemote) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoInfo struct {
	PublishInfo *GoPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GoInfo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler GoInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GoInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoInfo) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoPublishInfo struct {
	Owner   string `json:"owner" url:"owner"`
	Repo    string `json:"repo" url:"repo"`
	Version string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GoPublishInfo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler GoPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GoPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoPublishInfo) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type JavaInfo struct {
	PublishInfo *MavenPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JavaInfo) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JavaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler JavaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JavaInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JavaInfo) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The language and its associated publish information (if any).
// This is used to generate badges, the installation guide, and determine what language to
// use when surrounding the snippets in a code block.
type LanguageInfo struct {
	Type       string
	Typescript *TypescriptInfo
	Python     *PythonInfo
	Go         *GoInfo
	Java       *JavaInfo
	Ruby       *RubyInfo
	Csharp     *CsharpInfo
	Php        *PhpInfo
	Rust       *RustInfo
	Swift      *SwiftInfo
}

func (l *LanguageInfo) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "typescript":
		value := new(TypescriptInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Typescript = value
	case "python":
		value := new(PythonInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Python = value
	case "go":
		value := new(GoInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Go = value
	case "java":
		value := new(JavaInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Java = value
	case "ruby":
		value := new(RubyInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Ruby = value
	case "csharp":
		value := new(CsharpInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Csharp = value
	case "php":
		value := new(PhpInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Php = value
	case "rust":
		value := new(RustInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Rust = value
	case "swift":
		value := new(SwiftInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Swift = value
	}
	return nil
}

func (l LanguageInfo) MarshalJSON() ([]byte, error) {
	if l.Typescript != nil {
		return core.MarshalJSONWithExtraProperty(l.Typescript, "type", "typescript")
	}
	if l.Python != nil {
		return core.MarshalJSONWithExtraProperty(l.Python, "type", "python")
	}
	if l.Go != nil {
		return core.MarshalJSONWithExtraProperty(l.Go, "type", "go")
	}
	if l.Java != nil {
		return core.MarshalJSONWithExtraProperty(l.Java, "type", "java")
	}
	if l.Ruby != nil {
		return core.MarshalJSONWithExtraProperty(l.Ruby, "type", "ruby")
	}
	if l.Csharp != nil {
		return core.MarshalJSONWithExtraProperty(l.Csharp, "type", "csharp")
	}
	if l.Php != nil {
		return core.MarshalJSONWithExtraProperty(l.Php, "type", "php")
	}
	if l.Rust != nil {
		return core.MarshalJSONWithExtraProperty(l.Rust, "type", "rust")
	}
	if l.Swift != nil {
		return core.MarshalJSONWithExtraProperty(l.Swift, "type", "swift")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", l)
}

type LanguageInfoVisitor interface {
	VisitTypescript(*TypescriptInfo) error
	VisitPython(*PythonInfo) error
	VisitGo(*GoInfo) error
	VisitJava(*JavaInfo) error
	VisitRuby(*RubyInfo) error
	VisitCsharp(*CsharpInfo) error
	VisitPhp(*PhpInfo) error
	VisitRust(*RustInfo) error
	VisitSwift(*SwiftInfo) error
}

func (l *LanguageInfo) Accept(visitor LanguageInfoVisitor) error {
	if l.Typescript != nil {
		return visitor.VisitTypescript(l.Typescript)
	}
	if l.Python != nil {
		return visitor.VisitPython(l.Python)
	}
	if l.Go != nil {
		return visitor.VisitGo(l.Go)
	}
	if l.Java != nil {
		return visitor.VisitJava(l.Java)
	}
	if l.Ruby != nil {
		return visitor.VisitRuby(l.Ruby)
	}
	if l.Csharp != nil {
		return visitor.VisitCsharp(l.Csharp)
	}
	if l.Php != nil {
		return visitor.VisitPhp(l.Php)
	}
	if l.Rust != nil {
		return visitor.VisitRust(l.Rust)
	}
	if l.Swift != nil {
		return visitor.VisitSwift(l.Swift)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", l)
}

type MavenPublishInfo struct {
	Artifact string `json:"artifact" url:"artifact"`
	Group    string `json:"group" url:"group"`
	Version  string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MavenPublishInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MavenPublishInfo) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NpmPublishInfo struct {
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NpmPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NpmPublishInfo) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NugetPublishInfo struct {
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NugetPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NugetPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NugetPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NugetPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NugetPublishInfo) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type PhpInfo struct {
	PublishInfo *ComposerPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PhpInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhpInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PhpInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhpInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhpInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PypiPublishInfo struct {
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PypiPublishInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PypiPublishInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PythonInfo struct {
	PublishInfo *PypiPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PythonInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PythonInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PythonInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PythonInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PythonInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The configuration used to generate a README.md file.
// The information described here is a combination of user-defined information
// (i.e. specified in the generators.yml), and dynamically generated information
// that comes from each generator (i.e. features, requirements, and more).
type ReadmeConfig struct {
	// If specified, the original README.md will be fetched from this remote (if it exists).
	Remote                *Remote          `json:"remote,omitempty" url:"remote,omitempty"`
	Language              *LanguageInfo    `json:"language,omitempty" url:"language,omitempty"`
	Organization          string           `json:"organization" url:"organization"`
	ApiName               *string          `json:"apiName,omitempty" url:"apiName,omitempty"`
	BannerLink            *string          `json:"bannerLink,omitempty" url:"bannerLink,omitempty"`
	Introduction          *string          `json:"introduction,omitempty" url:"introduction,omitempty"`
	ApiReferenceLink      *string          `json:"apiReferenceLink,omitempty" url:"apiReferenceLink,omitempty"`
	ReferenceMarkdownPath *string          `json:"referenceMarkdownPath,omitempty" url:"referenceMarkdownPath,omitempty"`
	Requirements          []string         `json:"requirements,omitempty" url:"requirements,omitempty"`
	DisabledFeatures      []*FeatureId     `json:"disabledFeatures,omitempty" url:"disabledFeatures,omitempty"`
	WhiteLabel            *bool            `json:"whiteLabel,omitempty" url:"whiteLabel,omitempty"`
	CustomSections        []*CustomSection `json:"customSections,omitempty" url:"customSections,omitempty"`
	// Specifies the list of features supported by a specific generator.
	// The features are rendered in the order they're specified.
	Features []*ReadmeFeature `json:"features,omitempty" url:"features,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReadmeConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReadmeConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ReadmeConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReadmeConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReadmeConfig) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A single feature supported by a generator (e.g. PAGINATION).
type ReadmeFeature struct {
	Id          *FeatureId `json:"id,omitempty" url:"id,omitempty"`
	Description *string    `json:"description,omitempty" url:"description,omitempty"`
	Addendum    *string    `json:"addendum,omitempty" url:"addendum,omitempty"`
	Advanced    *bool      `json:"advanced,omitempty" url:"advanced,omitempty"`
	Snippets    []string   `json:"snippets,omitempty" url:"snippets,omitempty"`
	// If true, the feature block should be rendered even if we don't receive a snippet for it.
	// This is useful for features that are always supported, but might not require a snippet
	// to explain.
	SnippetsAreOptional bool `json:"snippetsAreOptional" url:"snippetsAreOptional"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReadmeFeature) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReadmeFeature) UnmarshalJSON(data []byte) error {
	type unmarshaler ReadmeFeature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReadmeFeature(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReadmeFeature) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The remote where the README.md is hosted.
type Remote struct {
	Type   string
	Github *GithubRemote
}

func (r *Remote) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "github":
		value := new(GithubRemote)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Github = value
	}
	return nil
}

func (r Remote) MarshalJSON() ([]byte, error) {
	if r.Github != nil {
		return core.MarshalJSONWithExtraProperty(r.Github, "type", "github")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type RemoteVisitor interface {
	VisitGithub(*GithubRemote) error
}

func (r *Remote) Accept(visitor RemoteVisitor) error {
	if r.Github != nil {
		return visitor.VisitGithub(r.Github)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

type RubyGemsPublishInfo struct {
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RubyGemsPublishInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyGemsPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RubyGemsPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RubyGemsPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RubyGemsPublishInfo) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RubyInfo struct {
	PublishInfo *RubyGemsPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RubyInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RubyInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RubyInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RubyInfo) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RustInfo struct {
	PublishInfo *CargoPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RustInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RustInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RustInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RustInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RustInfo) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SwiftInfo struct {
	PublishInfo *SwiftPackageManagerPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SwiftInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SwiftInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SwiftInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SwiftInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SwiftInfo) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SwiftPackageManagerPublishInfo struct {
	GitUrl     string `json:"gitUrl" url:"gitUrl"`
	MinVersion string `json:"minVersion" url:"minVersion"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SwiftPackageManagerPublishInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SwiftPackageManagerPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SwiftPackageManagerPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SwiftPackageManagerPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SwiftPackageManagerPublishInfo) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TypescriptInfo struct {
	PublishInfo *NpmPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TypescriptInfo) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TypescriptInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler TypescriptInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TypescriptInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TypescriptInfo) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type EndpointReference struct {
	// The title is a code snippet that is shown when the endpoint's reference is collapsed.
	// For example, `client.subpackage.method({ ...params }) -> ReturnValue`.
	Title       *MethodInvocationSnippet `json:"title,omitempty" url:"title,omitempty"`
	Description *string                  `json:"description,omitempty" url:"description,omitempty"`
	// A "full" snippet, showing all the parameters, with a full example.
	// ```typescript
	//
	//	await client.subpackage.method({
	//	    expiresIn: 300,
	//	});
	//
	// ```
	Snippet    string                `json:"snippet" url:"snippet"`
	Parameters []*ParameterReference `json:"parameters,omitempty" url:"parameters,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EndpointReference) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointReference) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointReference(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EndpointReference) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Language string

const (
	LanguageJava       Language = "JAVA"
	LanguagePython     Language = "PYTHON"
	LanguageGo         Language = "GO"
	LanguageRuby       Language = "RUBY"
	LanguageCsharp     Language = "CSHARP"
	LanguageTypescript Language = "TYPESCRIPT"
	LanguagePhp        Language = "PHP"
	LanguageRust       Language = "RUST"
	LanguageSwift      Language = "SWIFT"
)

func NewLanguageFromString(s string) (Language, error) {
	switch s {
	case "JAVA":
		return LanguageJava, nil
	case "PYTHON":
		return LanguagePython, nil
	case "GO":
		return LanguageGo, nil
	case "RUBY":
		return LanguageRuby, nil
	case "CSHARP":
		return LanguageCsharp, nil
	case "TYPESCRIPT":
		return LanguageTypescript, nil
	case "PHP":
		return LanguagePhp, nil
	case "RUST":
		return LanguageRust, nil
	case "SWIFT":
		return LanguageSwift, nil
	}
	var t Language
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l Language) Ptr() *Language {
	return &l
}

type LinkedText struct {
	Text     string            `json:"text" url:"text"`
	Location *RelativeLocation `json:"location,omitempty" url:"location,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LinkedText) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LinkedText) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkedText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkedText(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkedText) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The method invocation snippet is one which appears when the endpoint's reference is collapsed.
// It is meant to give a high-level overview of the endpoint -- e.g. the method name and it's return value.
// The snippet itself should be a list of concatable content, which the CLI will handle hyperlinking. Note that this
// will essentially just be a "".join(snippetParts), so you must handle making sure the right `.`, etc. are in the parts.
// Note this is a separate object to make it easier to add additional properties down the road, for example if
// we wanted to be specific about what portion of the snippet we hyperlink, etc.
type MethodInvocationSnippet struct {
	SnippetParts []*LinkedText `json:"snippetParts,omitempty" url:"snippetParts,omitempty"`
	ReturnValue  *LinkedText   `json:"returnValue,omitempty" url:"returnValue,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MethodInvocationSnippet) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MethodInvocationSnippet) UnmarshalJSON(data []byte) error {
	type unmarshaler MethodInvocationSnippet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MethodInvocationSnippet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MethodInvocationSnippet) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ParameterReference struct {
	Name        string            `json:"name" url:"name"`
	Description *string           `json:"description,omitempty" url:"description,omitempty"`
	Location    *RelativeLocation `json:"location,omitempty" url:"location,omitempty"`
	Type        string            `json:"type" url:"type"`
	Required    bool              `json:"required" url:"required"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ParameterReference) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ParameterReference) UnmarshalJSON(data []byte) error {
	type unmarshaler ParameterReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ParameterReference(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ParameterReference) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The information to include within the `reference.md` file generated by the CLI.
// The information here should really be all defined by the generator, and not user provided.
// We intentionally keep this a bit flexible in the event SDKs structure their package/module
// references in a unique way for the same API.
type ReferenceConfig struct {
	RootSection *RootPackageReferenceSection `json:"rootSection,omitempty" url:"rootSection,omitempty"`
	Sections    []*ReferenceSection          `json:"sections,omitempty" url:"sections,omitempty"`
	// Similar to in README generation, the language property is used to determine the language to use when generating code blocks in markdown.
	Language Language `json:"language" url:"language"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReferenceConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferenceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceConfig) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferenceSection struct {
	Title       string               `json:"title" url:"title"`
	Description *string              `json:"description,omitempty" url:"description,omitempty"`
	Endpoints   []*EndpointReference `json:"endpoints,omitempty" url:"endpoints,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReferenceSection) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferenceSection) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceSection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceSection(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceSection) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RelativeLocation struct {
	// A relative location is a path to a file or directory relative to the root of the repository.
	// This is used to specify a link for a type or a function that the `reference.md` can point users to.
	Path string `json:"path" url:"path"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RelativeLocation) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RelativeLocation) UnmarshalJSON(data []byte) error {
	type unmarshaler RelativeLocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RelativeLocation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RelativeLocation) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RootPackageReferenceSection struct {
	Description *string              `json:"description,omitempty" url:"description,omitempty"`
	Endpoints   []*EndpointReference `json:"endpoints,omitempty" url:"endpoints,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RootPackageReferenceSection) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RootPackageReferenceSection) UnmarshalJSON(data []byte) error {
	type unmarshaler RootPackageReferenceSection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RootPackageReferenceSection(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RootPackageReferenceSection) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
