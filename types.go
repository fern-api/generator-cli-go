// This file was auto-generated by Fern from our API Definition.

package generatorcli

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/fern-api/generator-cli-go/core"
)

// The configuration used to specify a generator's set of supported features.
// This is static data associated with a particular version of a generator, and
// is expected to be written as a static features.yml file in the generator's
// repository.
type FeatureConfig struct {
	Features []*FeatureSpec `json:"features,omitempty" url:"features,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FeatureConfig) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeatureConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler FeatureConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeatureConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeatureConfig) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// A unique identifier for a feature (e.g. OPTIONALS). This is typed as a freeform string
// to allow for arbitrary features, but callers are expected to use the FeatureType
// string representation whenever possible.
type FeatureId = string

// A specification for a feature supported by a generator. This includes the
// feature's ID, a description, and any additional information that should be
// included in the README.md.
type FeatureSpec struct {
	Id          FeatureId `json:"id" url:"id"`
	Description *string   `json:"description,omitempty" url:"description,omitempty"`
	Addendum    *string   `json:"addendum,omitempty" url:"addendum,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FeatureSpec) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeatureSpec) UnmarshalJSON(data []byte) error {
	type unmarshaler FeatureSpec
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeatureSpec(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeatureSpec) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Unique identifiers for features that can be demonstrated with snippets.
type FeatureType string

const (
	FeatureTypeAuthentication FeatureType = "AUTHENTICATION"
	FeatureTypeErrors         FeatureType = "ERRORS"
	FeatureTypeUsage          FeatureType = "USAGE"
	FeatureTypePagination     FeatureType = "PAGINATION"
	FeatureTypeRetries        FeatureType = "RETRIES"
	FeatureTypeRequestOptions FeatureType = "REQUEST_OPTIONS"
	FeatureTypeStreaming      FeatureType = "STREAMING"
	FeatureTypeTimeouts       FeatureType = "TIMEOUTS"
)

func NewFeatureTypeFromString(s string) (FeatureType, error) {
	switch s {
	case "AUTHENTICATION":
		return FeatureTypeAuthentication, nil
	case "ERRORS":
		return FeatureTypeErrors, nil
	case "USAGE":
		return FeatureTypeUsage, nil
	case "PAGINATION":
		return FeatureTypePagination, nil
	case "RETRIES":
		return FeatureTypeRetries, nil
	case "REQUEST_OPTIONS":
		return FeatureTypeRequestOptions, nil
	case "STREAMING":
		return FeatureTypeStreaming, nil
	case "TIMEOUTS":
		return FeatureTypeTimeouts, nil
	}
	var t FeatureType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FeatureType) Ptr() *FeatureType {
	return &f
}

type CsharpInfo struct {
	PublishInfo *NugetPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`
	title       string
	format      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CsharpInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CsharpInfo) Title() string {
	return c.title
}

func (c *CsharpInfo) Format() string {
	return c.format
}

func (c *CsharpInfo) UnmarshalJSON(data []byte) error {
	type embed CsharpInfo
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CsharpInfo(unmarshaler.embed)
	c.title = "C#"
	c.format = "csharp"

	extraProperties, err := core.ExtractExtraProperties(data, *c, "title", "format")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CsharpInfo) MarshalJSON() ([]byte, error) {
	type embed CsharpInfo
	var marshaler = struct {
		embed
		Title  string `json:"title"`
		Format string `json:"format"`
	}{
		embed:  embed(*c),
		Title:  "C#",
		Format: "csharp",
	}
	return json.Marshal(marshaler)
}

func (c *CsharpInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type GoInfo struct {
	PublishInfo *GoPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`
	title       string
	format      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GoInfo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoInfo) Title() string {
	return g.title
}

func (g *GoInfo) Format() string {
	return g.format
}

func (g *GoInfo) UnmarshalJSON(data []byte) error {
	type embed GoInfo
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoInfo(unmarshaler.embed)
	g.title = "Go"
	g.format = "go"

	extraProperties, err := core.ExtractExtraProperties(data, *g, "title", "format")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoInfo) MarshalJSON() ([]byte, error) {
	type embed GoInfo
	var marshaler = struct {
		embed
		Title  string `json:"title"`
		Format string `json:"format"`
	}{
		embed:  embed(*g),
		Title:  "Go",
		Format: "go",
	}
	return json.Marshal(marshaler)
}

func (g *GoInfo) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoPublishInfo struct {
	Owner   string `json:"owner" url:"owner"`
	Repo    string `json:"repo" url:"repo"`
	Version string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GoPublishInfo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler GoPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GoPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoPublishInfo) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type JavaInfo struct {
	PublishInfo *MavenPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`
	title       string
	format      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JavaInfo) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JavaInfo) Title() string {
	return j.title
}

func (j *JavaInfo) Format() string {
	return j.format
}

func (j *JavaInfo) UnmarshalJSON(data []byte) error {
	type embed JavaInfo
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*j),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*j = JavaInfo(unmarshaler.embed)
	j.title = "Java"
	j.format = "java"

	extraProperties, err := core.ExtractExtraProperties(data, *j, "title", "format")
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JavaInfo) MarshalJSON() ([]byte, error) {
	type embed JavaInfo
	var marshaler = struct {
		embed
		Title  string `json:"title"`
		Format string `json:"format"`
	}{
		embed:  embed(*j),
		Title:  "Java",
		Format: "java",
	}
	return json.Marshal(marshaler)
}

func (j *JavaInfo) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The language and its associated publish information (if any).
//
// This is used to generate badges, the installation guide, and determine what language to
// use when surrounding the snippets in a code block.
type LanguageInfo struct {
	Type       string
	Typescript *TypescriptInfo
	Python     *PythonInfo
	Go         *GoInfo
	Java       *JavaInfo
	Ruby       *RubyInfo
	Csharp     *CsharpInfo
}

func (l *LanguageInfo) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "typescript":
		value := new(TypescriptInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Typescript = value
	case "python":
		value := new(PythonInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Python = value
	case "go":
		value := new(GoInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Go = value
	case "java":
		value := new(JavaInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Java = value
	case "ruby":
		value := new(RubyInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Ruby = value
	case "csharp":
		value := new(CsharpInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Csharp = value
	}
	return nil
}

func (l LanguageInfo) MarshalJSON() ([]byte, error) {
	if l.Typescript != nil {
		return core.MarshalJSONWithExtraProperty(l.Typescript, "type", "typescript")
	}
	if l.Python != nil {
		return core.MarshalJSONWithExtraProperty(l.Python, "type", "python")
	}
	if l.Go != nil {
		return core.MarshalJSONWithExtraProperty(l.Go, "type", "go")
	}
	if l.Java != nil {
		return core.MarshalJSONWithExtraProperty(l.Java, "type", "java")
	}
	if l.Ruby != nil {
		return core.MarshalJSONWithExtraProperty(l.Ruby, "type", "ruby")
	}
	if l.Csharp != nil {
		return core.MarshalJSONWithExtraProperty(l.Csharp, "type", "csharp")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", l)
}

type LanguageInfoVisitor interface {
	VisitTypescript(*TypescriptInfo) error
	VisitPython(*PythonInfo) error
	VisitGo(*GoInfo) error
	VisitJava(*JavaInfo) error
	VisitRuby(*RubyInfo) error
	VisitCsharp(*CsharpInfo) error
}

func (l *LanguageInfo) Accept(visitor LanguageInfoVisitor) error {
	if l.Typescript != nil {
		return visitor.VisitTypescript(l.Typescript)
	}
	if l.Python != nil {
		return visitor.VisitPython(l.Python)
	}
	if l.Go != nil {
		return visitor.VisitGo(l.Go)
	}
	if l.Java != nil {
		return visitor.VisitJava(l.Java)
	}
	if l.Ruby != nil {
		return visitor.VisitRuby(l.Ruby)
	}
	if l.Csharp != nil {
		return visitor.VisitCsharp(l.Csharp)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", l)
}

type MavenPublishInfo struct {
	Artifact string `json:"artifact" url:"artifact"`
	Group    string `json:"group" url:"group"`
	Version  string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MavenPublishInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MavenPublishInfo) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NpmPublishInfo struct {
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NpmPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NpmPublishInfo) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NugetPublishInfo struct {
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NugetPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NugetPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NugetPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NugetPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NugetPublishInfo) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type PypiPublishInfo struct {
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PypiPublishInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PypiPublishInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PythonInfo struct {
	PublishInfo *PypiPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`
	title       string
	format      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PythonInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PythonInfo) Title() string {
	return p.title
}

func (p *PythonInfo) Format() string {
	return p.format
}

func (p *PythonInfo) UnmarshalJSON(data []byte) error {
	type embed PythonInfo
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PythonInfo(unmarshaler.embed)
	p.title = "Python"
	p.format = "python"

	extraProperties, err := core.ExtractExtraProperties(data, *p, "title", "format")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PythonInfo) MarshalJSON() ([]byte, error) {
	type embed PythonInfo
	var marshaler = struct {
		embed
		Title  string `json:"title"`
		Format string `json:"format"`
	}{
		embed:  embed(*p),
		Title:  "Python",
		Format: "python",
	}
	return json.Marshal(marshaler)
}

func (p *PythonInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The configuration used to generate a README.md file.
//
// The information described here is a combination of user-defined information
// (i.e. specified in the generators.yml), and dynamically generated information
// that comes from each generator (i.e. features, requirements, and more).
type ReadmeConfig struct {
	Language     *LanguageInfo `json:"language,omitempty" url:"language,omitempty"`
	Organization string        `json:"organization" url:"organization"`
	BannerLink   *string       `json:"bannerLink,omitempty" url:"bannerLink,omitempty"`
	DocsLink     *string       `json:"docsLink,omitempty" url:"docsLink,omitempty"`
	Requirements []string      `json:"requirements,omitempty" url:"requirements,omitempty"`
	// Specifies the list of features supported by a specific generator.
	// The features are rendered in the order they're specified.
	Features []*ReadmeFeature `json:"features,omitempty" url:"features,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReadmeConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReadmeConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ReadmeConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReadmeConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReadmeConfig) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A single feature supported by a generator (e.g. PAGINATION).
type ReadmeFeature struct {
	Id          FeatureId `json:"id" url:"id"`
	Description *string   `json:"description,omitempty" url:"description,omitempty"`
	Addendum    *string   `json:"addendum,omitempty" url:"addendum,omitempty"`
	Snippets    []string  `json:"snippets,omitempty" url:"snippets,omitempty"`
	// If true, the feature block should be rendered even if we don't receive a snippet for it.
	// This is useful for features that are always supported, but might not require a snippet
	// to explain.
	SnippetsAreOptional bool `json:"snippetsAreOptional" url:"snippetsAreOptional"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReadmeFeature) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReadmeFeature) UnmarshalJSON(data []byte) error {
	type unmarshaler ReadmeFeature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReadmeFeature(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReadmeFeature) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RubyGemsPublishInfo struct {
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RubyGemsPublishInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyGemsPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RubyGemsPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RubyGemsPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RubyGemsPublishInfo) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RubyInfo struct {
	PublishInfo *RubyGemsPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`
	title       string
	format      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RubyInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyInfo) Title() string {
	return r.title
}

func (r *RubyInfo) Format() string {
	return r.format
}

func (r *RubyInfo) UnmarshalJSON(data []byte) error {
	type embed RubyInfo
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RubyInfo(unmarshaler.embed)
	r.title = "Ruby"
	r.format = "ruby"

	extraProperties, err := core.ExtractExtraProperties(data, *r, "title", "format")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RubyInfo) MarshalJSON() ([]byte, error) {
	type embed RubyInfo
	var marshaler = struct {
		embed
		Title  string `json:"title"`
		Format string `json:"format"`
	}{
		embed:  embed(*r),
		Title:  "Ruby",
		Format: "ruby",
	}
	return json.Marshal(marshaler)
}

func (r *RubyInfo) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type TypescriptInfo struct {
	PublishInfo *NpmPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`
	title       string
	format      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TypescriptInfo) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TypescriptInfo) Title() string {
	return t.title
}

func (t *TypescriptInfo) Format() string {
	return t.format
}

func (t *TypescriptInfo) UnmarshalJSON(data []byte) error {
	type embed TypescriptInfo
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TypescriptInfo(unmarshaler.embed)
	t.title = "TypeScript"
	t.format = "ts"

	extraProperties, err := core.ExtractExtraProperties(data, *t, "title", "format")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TypescriptInfo) MarshalJSON() ([]byte, error) {
	type embed TypescriptInfo
	var marshaler = struct {
		embed
		Title  string `json:"title"`
		Format string `json:"format"`
	}{
		embed:  embed(*t),
		Title:  "TypeScript",
		Format: "ts",
	}
	return json.Marshal(marshaler)
}

func (t *TypescriptInfo) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}
